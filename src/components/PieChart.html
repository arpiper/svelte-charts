<div class="pie-chart-container">
  {{ yield }}
</div>

<script>
var d3 = require("d3")

export default {
  data () {
    return {
      dataset: {},
      size: {},
      selector: "",
      svg: undefined,
      scales: undefined,
      axes: undefined,
      radius: 100,
      innerRadius: 0,
      options: {},
    }
  },
  methods: {
    drawWedges () {
      let svg, size, data, scales, r, ir
      svg = this.get("svg")
      size = this.get("size")
      data = this.get("dataset")
      scales = this.get("scales")
      r = this.get("radius")
      ir = this.get("innerRadius")
      data.colors = []
      let wedges = d3.pie()(data.y)
      data.wedges = wedges
      let arc = d3.arc().innerRadius(ir).outerRadius(r)
      let g = svg.append("g")
        .attr("transform", `translate(${size.width / 2},${size.height / 2})`)
      let lines = this.drawLines()
      g.selectAll("path").data(wedges)
        .enter().append("path")
          .attr("class", "pie-slice")
          .attr("fill", (d,i) => {
            data.colors.push(d3.schemeCategory20[i])
            return d3.schemeCategory20[i]
          })
          .attr("d", (d) => arc(d))
          .on("mouseover", (d,i) => {
            document.querySelector(`#hover-line-${i}`).style.opacity = 1
          })
          .on("mouseout", (d,i) => {
            document.querySelector(`#hover-line-${i}`).style.opacity = 0
          })
    },
    drawLines () {
      let svg, size, data, r, ir
      svg = this.get("svg")
      size = this.get("size")
      data = this.get("dataset")
      r = this.get("radius")
      ir = this.get("innerRadius")
      console.log(data.wedges)
      let arc = d3.arc().innerRadius(ir).outerRadius(r)
      let g = svg.append("g")
        .attr("transform", `translate(${size.width / 2}, ${size.height / 2})`)
      g = g.selectAll("g").data(data.y)
        .enter().append("g")
          .attr("class", "hover-line")
          .attr("id", (d,i) => `hover-line-${i}`)
          .attr("opacity", 0)
      g.append("line")
          .attr("x1", (d,i) => arc.centroid(data.wedges[i])[0])
          .attr("y1", (d,i) => arc.centroid(data.wedges[i])[1])
          .attr("x2", (d,i) => {
            let a = (data.wedges[i].startAngle + data.wedges[i].endAngle) / 2
            let c = arc.centroid(data.wedges[i])
            if (c[0] > 0 && c[1] > 0) {
              return c[0] + (50 * Math.sin(a))
            } else if (c[0] > 0) {
              return c[0] - (50 * Math.cos((a - (3/2)*Math.PI)))
            } else if (c[1] > 0) {
              return c[0] + (50 * Math.cos((a - (1/2)*Math.PI)))
            }
            return c[0] - (50 * Math.sin(a - Math.PI))
          })
          .attr("y2", (d,i) => {
            let a = (data.wedges[i].startAngle + data.wedges[i].endAngle) / 2
            let c = arc.centroid(data.wedges[i])
            if (c[0] > 0 && c[1] > 0) {
              return c[1] - (50 * Math.cos(a))
            } else if (c[0] > 0) {
              return c[1] - (50 * Math.sin((a - (3/2)*Math.PI)))
            } else if (c[1] > 0) {
              return c[1] + (50 * Math.sin((a - (1/2)*Math.PI)))
            }
            return c[1] + (50 * Math.cos(a - Math.PI))
          })
          .attr("stroke", 'red')
          .attr("stroke-width", 1)
      g.append("line")
        .attr("x1", (d,i) => {
            let a = (data.wedges[i].startAngle + data.wedges[i].endAngle) / 2
            let c = arc.centroid(data.wedges[i])
            if (c[0] > 0 && c[1] > 0) {
              return c[0] + (50 * Math.sin(a))
            } else if (c[0] > 0) {
              return c[0] - (50 * Math.cos((a - (3/2)*Math.PI)))
            } else if (c[1] > 0) {
              return c[0] + (50 * Math.cos((a - (1/2)*Math.PI)))
            }
            return c[0] - (50 * Math.sin(a - Math.PI))
          })
        .attr("y1", (d,i) => {
            let a = (data.wedges[i].startAngle + data.wedges[i].endAngle) / 2
            let c = arc.centroid(data.wedges[i])
            if (c[0] > 0 && c[1] > 0) {
              return c[1] - (50 * Math.cos(a))
            } else if (c[0] > 0) {
              return c[1] - (50 * Math.sin((a - (3/2)*Math.PI)))
            } else if (c[1] > 0) {
              return c[1] + (50 * Math.sin((a - (1/2)*Math.PI)))
            }
            return c[1] + (50 * Math.cos(a - Math.PI))
          })
        .attr("x2",  (d,i) => {
            let a = (data.wedges[i].startAngle + data.wedges[i].endAngle) / 2
            let c = arc.centroid(data.wedges[i])
            if (c[0] > 0 && c[1] > 0) {
              return c[0] + (50 * Math.sin(a)) + 150
            } else if (c[0] > 0) {
              return c[0] - (50 * Math.cos((a - (3/2)*Math.PI))) + 150
            } else if (c[1] > 0) {
              return c[0] + (50 * Math.cos((a - (1/2)*Math.PI))) + 150
            }
            return c[0] - (50 * Math.sin(a - Math.PI)) + 150
          })
        .attr("y2", (d,i) => {
            let a = (data.wedges[i].startAngle + data.wedges[i].endAngle) / 2
            let c = arc.centroid(data.wedges[i])
            if (c[0] > 0 && c[1] > 0) {
              return c[1] - (50 * Math.cos(a))
            } else if (c[0] > 0) {
              return c[1] - (50 * Math.sin((a - (3/2)*Math.PI)))
            } else if (c[1] > 0) {
              return c[1] + (50 * Math.sin((a - (1/2)*Math.PI)))
            }
            return c[1] + (50 * Math.cos(a - Math.PI))
          })
        .attr("stroke", "blue")
      return g
    },
    drawKey () {
      let svg, data, size, key_block_spacing, key_size
      svg = this.get("svg")
      data = this.get("dataset")
      size = this.get("size")
      key_block_spacing = 15
      key_size = 10
      // too many items for the svg height.
      if ((size.height - 2 * size.margin) < (data.y.length * 15)) {
        key_block_spacing = (size.height - 2 * size.margin) / data.y.length
        key_size = key_block_spacing - 2
      }
      let g = svg.append("g")
          .attr("transform", `translate(${size.margin}, ${size.margin})`)
        .selectAll("g").data(data.x)
          .enter().append("g")
            .attr("class", "key-block")
            .attr("transform", (d,i) => `translate(0, ${i * key_block_spacing})`)
      g.append("rect")
        .attr("width", key_size)
        .attr("height", key_size)
        .attr("x", 0)
        .attr("y", -key_size)
        .attr("fill", (d,i) => data.colors[i])
      g.append("text")
        .attr("x", (key_size + 5))
        .text((d,i) => `${d} - ${data.y[i]}`)
        .attr("font-size", key_size)
    },
  },
  oncreate () {
    let selector = this.get("selector")
    let s = this.get("size")
    let r = (s.width > s.height) ? (s.height - s.margin * 2) / 2 : (s.width - s.margin * 2) / 2
    this.set({
      svg: d3.select(`#${selector}`),
      radius: r,
    })
    this.drawWedges()
    this.drawKey()
    //this.drawLines()
  },
}
</script>

<style>
.key-block text {
  font-family: Avenir, Arial, sans-serif;
  dominant-baseline: text-after-edge;
}
.pie-chart-container {
  border: 1px solid black;
}
</style>
